# **json processing**

## Context

Documentation used to describe with a bit more of details about the functions implemented in `src/modules/json_processing.py`.
It is a work in progress and will be updated as we add more features.

## **get_motion_vectors**

### Description

This function is used to get the motion vectors out of AV1 metadata. Motion Vectors are one of the metadatas generated by the encoder. Using AOM inspect tool, we can, while decoding the video, retrieve that data and store it in a json file. This function is used to read the data from the json file and generate a coherent motion field.

#### Arguments

- `frame_metadata`: Metadata of the frame.

#### Returns

- `motion_vectors`: Motion vectors.

### Details

#### Type of data

The motion vectors are stored as a list of list of list of integers: [[[int, int, int, int], ...], ...].

#### Shape of the motion vector array

For a 1920x1080 video, the shape of the generated motion vector array would be: 
- width: (1920 / MiCol)
- height: (1080 / MiRow)
- channels: 4 (x_backward, y_backward, x_forward, y_forward)

In a more general way:
- mv_width = width / MiCol
- mv_height = height / MiRow
- mv_channels = 4

MiCol and MiRow being usually the same number which is 4 (the size of the smallest block supported by AV1).

AV1 does support non non-power-of-two resolutions. Let us take the exemple of a 1920x1088 video.  
A 1920x1088 frame would be split into:
- 9 vertical 128x128 super-blocks (1088 / 128 = 8.5 &rarr; 9)
- final row containes 128x64 partial superblock
- Partial superblocks use replication padding but aren't output

> Replication padding: AV1 uses edge replication for partial blocks during motion compensation and intra prediction. The last valid sample row/column is duplicated to fill incomplete suplerblocks

Therefore, in order to keep the same shape as the original frame, we use a padding function to remove the potential extra values. However this padding is done only if needed.

#### Precision of the motion vectors

Motion vectors use 1/8th pixel precision when `allow_high_precision_mv=1` otherwise it is 1/4th pixel precision.

A sub-pixel is generated through separable interpolation filters. A typical exemple being to:
1. Compute the horizontal interpolation
2. A vertical filter is then applied to the generated result to produce the final sub-pixel 

